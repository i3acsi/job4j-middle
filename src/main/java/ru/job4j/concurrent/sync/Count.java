package ru.job4j.concurrent.sync;

import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;


/*
@ThreadSafe - эта аннотация, говорит пользователям данного класса, что класс можно использовать в многопоточном режиме
и он будет работать правильно.
 */
@ThreadSafe
public class Count {
    @GuardedBy("this")
    private int value;

    public synchronized void increment() {
        this.value++;
    }

    public synchronized int get() {
        return this.value;
    }
}
/*
напишем на него тест, который будет демонстрировать применения данного кода.

Тест у нас будет состоять из двух нитей.
Каждая нить будет дергать счетчик и увеличивать его значение на единицу.
В конце теста мы проверим, что наш счетчик увеличился на нужное количество раз.
 */

/*
@GuardedBy("this") - эта аннотация выставляется над общим ресурсом. Аннотация имеет входящий параметр. Он указывает на объект монитора,
по которому мы будет синхронизироваться.
Программист должен работать с этим ресурсом только в критической секции, которая синхронизируется по объекту монитора, который указан в аннотации.
Если мы запустим тест заново, то результат будет прежним.
Хотя класс Count все еще написан не верно.
Среда разработки IDEA позволяет указать разработчику на проблемный код, который описан через аннотации jcip.
Для этого нужно включить режим индикации этих аннотаций.
Заходим в настройки IDEA
В поиске набираем jcip
Отмечаем галками все пункты относящиеся к этой библиотеке.
Теперь откроем код и посмотрим. что среда подсвечивает ошибки.
Так же, такие операторы в среде подсвечены коричневым.
Теперь давайте добавим синхронизацию и посмотрим, что скажет IDEA.
Как мы видим среда теперь показывает, что код верный.
Запомните, что аннотации jcip - это как JavaDoc - он нужен, только чтобы описать класс, который будет работать в многопоточности.
Синхронизацию эти аннотации не добавляют.

Задание.
 */